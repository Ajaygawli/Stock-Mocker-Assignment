{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule DraftEditorCompositionHandler\r\n * @format\r\n * \r\n */\n\n'use strict';\n\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftModifier = require('./DraftModifier');\nvar EditorState = require('./EditorState');\nvar Keys = require('fbjs/lib/Keys');\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\nvar isEventHandled = require('./isEventHandled');\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\n\n/**\r\n * Millisecond delay to allow `compositionstart` to fire again upon\r\n * `compositionend`.\r\n *\r\n * This is used for Korean input to ensure that typing can continue without\r\n * the editor trying to render too quickly. More specifically, Safari 7.1+\r\n * triggers `compositionstart` a little slower than Chrome/FF, which\r\n * leads to composed characters being resolved and re-render occurring\r\n * sooner than we want.\r\n */\nvar RESOLVE_DELAY = 20;\n\n/**\r\n * A handful of variables used to track the current composition and its\r\n * resolution status. These exist at the module level because it is not\r\n * possible to have compositions occurring in multiple editors simultaneously,\r\n * and it simplifies state management with respect to the DraftEditor component.\r\n */\nvar resolved = false;\nvar stillComposing = false;\nvar textInputData = '';\nvar DraftEditorCompositionHandler = {\n  onBeforeInput: function onBeforeInput(editor, e) {\n    textInputData = (textInputData || '') + e.data;\n  },\n  /**\r\n   * A `compositionstart` event has fired while we're still in composition\r\n   * mode. Continue the current composition session to prevent a re-render.\r\n   */\n  onCompositionStart: function onCompositionStart(editor) {\n    stillComposing = true;\n  },\n  /**\r\n   * Attempt to end the current composition session.\r\n   *\r\n   * Defer handling because browser will still insert the chars into active\r\n   * element after `compositionend`. If a `compositionstart` event fires\r\n   * before `resolveComposition` executes, our composition session will\r\n   * continue.\r\n   *\r\n   * The `resolved` flag is useful because certain IME interfaces fire the\r\n   * `compositionend` event multiple times, thus queueing up multiple attempts\r\n   * at handling the composition. Since handling the same composition event\r\n   * twice could break the DOM, we only use the first event. Example: Arabic\r\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\r\n   */\n  onCompositionEnd: function onCompositionEnd(editor) {\n    resolved = false;\n    stillComposing = false;\n    setTimeout(function () {\n      if (!resolved) {\n        DraftEditorCompositionHandler.resolveComposition(editor);\n      }\n    }, RESOLVE_DELAY);\n  },\n  /**\r\n   * In Safari, keydown events may fire when committing compositions. If\r\n   * the arrow keys are used to commit, prevent default so that the cursor\r\n   * doesn't move, otherwise it will jump back noticeably on re-render.\r\n   */\n  onKeyDown: function onKeyDown(editor, e) {\n    if (!stillComposing) {\n      // If a keydown event is received after compositionend but before the\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\n      // backspace in 2-Set Korean), we should immediately resolve the\n      // composition and reinterpret the key press in edit mode.\n      DraftEditorCompositionHandler.resolveComposition(editor);\n      editor._onKeyDown(e);\n      return;\n    }\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\n      e.preventDefault();\n    }\n  },\n  /**\r\n   * Keypress events may fire when committing compositions. In Firefox,\r\n   * pressing RETURN commits the composition and inserts extra newline\r\n   * characters that we do not want. `preventDefault` allows the composition\r\n   * to be committed while preventing the extra characters.\r\n   */\n  onKeyPress: function onKeyPress(editor, e) {\n    if (e.which === Keys.RETURN) {\n      e.preventDefault();\n    }\n  },\n  /**\r\n   * Attempt to insert composed characters into the document.\r\n   *\r\n   * If we are still in a composition session, do nothing. Otherwise, insert\r\n   * the characters into the document and terminate the composition session.\r\n   *\r\n   * If no characters were composed -- for instance, the user\r\n   * deleted all composed characters and committed nothing new --\r\n   * force a re-render. We also re-render when the composition occurs\r\n   * at the beginning of a leaf, to ensure that if the browser has\r\n   * created a new text node for the composition, we will discard it.\r\n   *\r\n   * Resetting innerHTML will move focus to the beginning of the editor,\r\n   * so we update to force it back to the correct place.\r\n   */\n  resolveComposition: function resolveComposition(editor) {\n    if (stillComposing) {\n      return;\n    }\n    resolved = true;\n    var composedChars = textInputData;\n    textInputData = '';\n    var editorState = EditorState.set(editor._latestEditorState, {\n      inCompositionMode: false\n    });\n    var currentStyle = editorState.getCurrentInlineStyle();\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\n    if (mustReset) {\n      editor.restoreEditorDOM();\n    }\n    editor.exitCurrentMode();\n    if (composedChars) {\n      if (DraftFeatureFlags.draft_handlebeforeinput_composed_text && editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(composedChars, editorState))) {\n        return;\n      }\n      // If characters have been composed, re-rendering with the update\n      // is sufficient to reset the editor.\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\n      return;\n    }\n    if (mustReset) {\n      editor.update(EditorState.set(editorState, {\n        nativelyRenderedContent: null,\n        forceSelection: true\n      }));\n    }\n  }\n};\nmodule.exports = DraftEditorCompositionHandler;","map":{"version":3,"names":["DraftFeatureFlags","require","DraftModifier","EditorState","Keys","getEntityKeyForSelection","isEventHandled","isSelectionAtLeafStart","RESOLVE_DELAY","resolved","stillComposing","textInputData","DraftEditorCompositionHandler","onBeforeInput","editor","e","data","onCompositionStart","onCompositionEnd","setTimeout","resolveComposition","onKeyDown","_onKeyDown","which","RIGHT","LEFT","preventDefault","onKeyPress","RETURN","composedChars","editorState","set","_latestEditorState","inCompositionMode","currentStyle","getCurrentInlineStyle","entityKey","getCurrentContent","getSelection","mustReset","size","restoreEditorDOM","exitCurrentMode","draft_handlebeforeinput_composed_text","props","handleBeforeInput","contentState","replaceText","update","push","nativelyRenderedContent","forceSelection","module","exports"],"sources":["C:/Users/ajayg/Desktop/vssample/stock_mocker/client/node_modules/draft-js/lib/DraftEditorCompositionHandler.js"],"sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule DraftEditorCompositionHandler\r\n * @format\r\n * \r\n */\r\n\r\n'use strict';\r\n\r\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\r\nvar DraftModifier = require('./DraftModifier');\r\nvar EditorState = require('./EditorState');\r\nvar Keys = require('fbjs/lib/Keys');\r\n\r\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\r\nvar isEventHandled = require('./isEventHandled');\r\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\r\n\r\n/**\r\n * Millisecond delay to allow `compositionstart` to fire again upon\r\n * `compositionend`.\r\n *\r\n * This is used for Korean input to ensure that typing can continue without\r\n * the editor trying to render too quickly. More specifically, Safari 7.1+\r\n * triggers `compositionstart` a little slower than Chrome/FF, which\r\n * leads to composed characters being resolved and re-render occurring\r\n * sooner than we want.\r\n */\r\nvar RESOLVE_DELAY = 20;\r\n\r\n/**\r\n * A handful of variables used to track the current composition and its\r\n * resolution status. These exist at the module level because it is not\r\n * possible to have compositions occurring in multiple editors simultaneously,\r\n * and it simplifies state management with respect to the DraftEditor component.\r\n */\r\nvar resolved = false;\r\nvar stillComposing = false;\r\nvar textInputData = '';\r\n\r\nvar DraftEditorCompositionHandler = {\r\n  onBeforeInput: function onBeforeInput(editor, e) {\r\n    textInputData = (textInputData || '') + e.data;\r\n  },\r\n\r\n  /**\r\n   * A `compositionstart` event has fired while we're still in composition\r\n   * mode. Continue the current composition session to prevent a re-render.\r\n   */\r\n  onCompositionStart: function onCompositionStart(editor) {\r\n    stillComposing = true;\r\n  },\r\n\r\n  /**\r\n   * Attempt to end the current composition session.\r\n   *\r\n   * Defer handling because browser will still insert the chars into active\r\n   * element after `compositionend`. If a `compositionstart` event fires\r\n   * before `resolveComposition` executes, our composition session will\r\n   * continue.\r\n   *\r\n   * The `resolved` flag is useful because certain IME interfaces fire the\r\n   * `compositionend` event multiple times, thus queueing up multiple attempts\r\n   * at handling the composition. Since handling the same composition event\r\n   * twice could break the DOM, we only use the first event. Example: Arabic\r\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\r\n   */\r\n  onCompositionEnd: function onCompositionEnd(editor) {\r\n    resolved = false;\r\n    stillComposing = false;\r\n    setTimeout(function () {\r\n      if (!resolved) {\r\n        DraftEditorCompositionHandler.resolveComposition(editor);\r\n      }\r\n    }, RESOLVE_DELAY);\r\n  },\r\n\r\n  /**\r\n   * In Safari, keydown events may fire when committing compositions. If\r\n   * the arrow keys are used to commit, prevent default so that the cursor\r\n   * doesn't move, otherwise it will jump back noticeably on re-render.\r\n   */\r\n  onKeyDown: function onKeyDown(editor, e) {\r\n    if (!stillComposing) {\r\n      // If a keydown event is received after compositionend but before the\r\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\r\n      // backspace in 2-Set Korean), we should immediately resolve the\r\n      // composition and reinterpret the key press in edit mode.\r\n      DraftEditorCompositionHandler.resolveComposition(editor);\r\n      editor._onKeyDown(e);\r\n      return;\r\n    }\r\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\r\n      e.preventDefault();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Keypress events may fire when committing compositions. In Firefox,\r\n   * pressing RETURN commits the composition and inserts extra newline\r\n   * characters that we do not want. `preventDefault` allows the composition\r\n   * to be committed while preventing the extra characters.\r\n   */\r\n  onKeyPress: function onKeyPress(editor, e) {\r\n    if (e.which === Keys.RETURN) {\r\n      e.preventDefault();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to insert composed characters into the document.\r\n   *\r\n   * If we are still in a composition session, do nothing. Otherwise, insert\r\n   * the characters into the document and terminate the composition session.\r\n   *\r\n   * If no characters were composed -- for instance, the user\r\n   * deleted all composed characters and committed nothing new --\r\n   * force a re-render. We also re-render when the composition occurs\r\n   * at the beginning of a leaf, to ensure that if the browser has\r\n   * created a new text node for the composition, we will discard it.\r\n   *\r\n   * Resetting innerHTML will move focus to the beginning of the editor,\r\n   * so we update to force it back to the correct place.\r\n   */\r\n  resolveComposition: function resolveComposition(editor) {\r\n    if (stillComposing) {\r\n      return;\r\n    }\r\n\r\n    resolved = true;\r\n    var composedChars = textInputData;\r\n    textInputData = '';\r\n\r\n    var editorState = EditorState.set(editor._latestEditorState, {\r\n      inCompositionMode: false\r\n    });\r\n\r\n    var currentStyle = editorState.getCurrentInlineStyle();\r\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\r\n\r\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\r\n\r\n    if (mustReset) {\r\n      editor.restoreEditorDOM();\r\n    }\r\n\r\n    editor.exitCurrentMode();\r\n\r\n    if (composedChars) {\r\n      if (DraftFeatureFlags.draft_handlebeforeinput_composed_text && editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(composedChars, editorState))) {\r\n        return;\r\n      }\r\n      // If characters have been composed, re-rendering with the update\r\n      // is sufficient to reset the editor.\r\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\r\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\r\n      return;\r\n    }\r\n\r\n    if (mustReset) {\r\n      editor.update(EditorState.set(editorState, {\r\n        nativelyRenderedContent: null,\r\n        forceSelection: true\r\n      }));\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = DraftEditorCompositionHandler;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}