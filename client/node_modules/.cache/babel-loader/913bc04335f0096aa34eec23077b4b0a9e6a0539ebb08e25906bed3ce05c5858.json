{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule insertFragmentIntoContentState\r\n * @format\r\n * \r\n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\nvar insertIntoList = require('./insertIntoList');\nvar invariant = require('fbjs/lib/invariant');\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\nvar List = Immutable.List;\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\r\n * Appends text/characterList from the fragment first block to\r\n * target block.\r\n */\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n\n/**\r\n * Appends offset text/characterList from the target block to the last\r\n * fragment block.\r\n */\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = [];\n\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n    if (!lastSiblingKey) {\n      break;\n    }\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n  return rootBlocks;\n};\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    }\n\n    // update the last root block fragment\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\n\n    // update the original target next block\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    }\n\n    // update fragment parent links\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    });\n\n    // update targetBlock parent child links\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\n\n      // insert fragment children\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    }\n\n    // Insert fragment blocks after the head and before the tail.\n    fragment\n    // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    });\n\n    // update tail\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  }\n\n  // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\nmodule.exports = insertFragmentIntoContentState;","map":{"version":3,"names":["BlockMapBuilder","require","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","length","newBlock","merge","slice","characterList","data","getData","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","type","getType","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","process","env","NODE_ENV","getBlockMap","getStartKey","getStartOffset","module","exports"],"sources":["C:/Users/ajayg/Desktop/vssample/stock_mocker/client/node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule insertFragmentIntoContentState\r\n * @format\r\n * \r\n */\r\n\r\n'use strict';\r\n\r\nvar BlockMapBuilder = require('./BlockMapBuilder');\r\nvar ContentBlockNode = require('./ContentBlockNode');\r\nvar Immutable = require('immutable');\r\n\r\nvar insertIntoList = require('./insertIntoList');\r\nvar invariant = require('fbjs/lib/invariant');\r\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\r\n\r\nvar List = Immutable.List;\r\n\r\n\r\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\r\n  var targetBlock = blockMap.get(targetKey);\r\n  var text = targetBlock.getText();\r\n  var chars = targetBlock.getCharacterList();\r\n  var finalKey = targetKey;\r\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\r\n\r\n  var newBlock = targetBlock.merge({\r\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\r\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\r\n    data: fragmentBlock.getData()\r\n  });\r\n\r\n  return contentState.merge({\r\n    blockMap: blockMap.set(targetKey, newBlock),\r\n    selectionBefore: selectionState,\r\n    selectionAfter: selectionState.merge({\r\n      anchorKey: finalKey,\r\n      anchorOffset: finalOffset,\r\n      focusKey: finalKey,\r\n      focusOffset: finalOffset,\r\n      isBackward: false\r\n    })\r\n  });\r\n};\r\n\r\n/**\r\n * Appends text/characterList from the fragment first block to\r\n * target block.\r\n */\r\nvar updateHead = function updateHead(block, targetOffset, fragment) {\r\n  var text = block.getText();\r\n  var chars = block.getCharacterList();\r\n\r\n  // Modify head portion of block.\r\n  var headText = text.slice(0, targetOffset);\r\n  var headCharacters = chars.slice(0, targetOffset);\r\n  var appendToHead = fragment.first();\r\n\r\n  return block.merge({\r\n    text: headText + appendToHead.getText(),\r\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\r\n    type: headText ? block.getType() : appendToHead.getType(),\r\n    data: appendToHead.getData()\r\n  });\r\n};\r\n\r\n/**\r\n * Appends offset text/characterList from the target block to the last\r\n * fragment block.\r\n */\r\nvar updateTail = function updateTail(block, targetOffset, fragment) {\r\n  // Modify tail portion of block.\r\n  var text = block.getText();\r\n  var chars = block.getCharacterList();\r\n\r\n  // Modify head portion of block.\r\n  var blockSize = text.length;\r\n  var tailText = text.slice(targetOffset, blockSize);\r\n  var tailCharacters = chars.slice(targetOffset, blockSize);\r\n  var prependToTail = fragment.last();\r\n\r\n  return prependToTail.merge({\r\n    text: prependToTail.getText() + tailText,\r\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\r\n    data: prependToTail.getData()\r\n  });\r\n};\r\n\r\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\r\n  var headKey = block.getKey();\r\n  var rootBlock = block;\r\n  var rootBlocks = [];\r\n\r\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\r\n  // the fragment head is used to update the target block, however when this does not happen we need\r\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\r\n  // fragment root block\r\n  if (blockMap.get(headKey)) {\r\n    rootBlocks.push(headKey);\r\n  }\r\n\r\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\r\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\r\n\r\n    if (!lastSiblingKey) {\r\n      break;\r\n    }\r\n\r\n    rootBlocks.push(lastSiblingKey);\r\n    rootBlock = blockMap.get(lastSiblingKey);\r\n  }\r\n\r\n  return rootBlocks;\r\n};\r\n\r\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\r\n  return blockMap.withMutations(function (blockMapState) {\r\n    var targetKey = targetBlock.getKey();\r\n    var headKey = fragmentHeadBlock.getKey();\r\n    var targetNextKey = targetBlock.getNextSiblingKey();\r\n    var targetParentKey = targetBlock.getParentKey();\r\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\r\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\r\n\r\n    if (blockMapState.get(headKey)) {\r\n      // update the fragment head when it is part of the blockMap otherwise\r\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\r\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\r\n    } else {\r\n      // update the target block that had the fragment head contents merged into it\r\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\r\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\r\n    }\r\n\r\n    // update the last root block fragment\r\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\r\n\r\n    // update the original target next block\r\n    if (targetNextKey) {\r\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\r\n    }\r\n\r\n    // update fragment parent links\r\n    fragmentRootBlocks.forEach(function (blockKey) {\r\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\r\n    });\r\n\r\n    // update targetBlock parent child links\r\n    if (targetParentKey) {\r\n      var targetParent = blockMap.get(targetParentKey);\r\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\r\n\r\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\r\n      var insertionIndex = targetBlockIndex + 1;\r\n\r\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\r\n\r\n      // insert fragment children\r\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\r\n\r\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\r\n    }\r\n  });\r\n};\r\n\r\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\r\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\r\n  var newBlockArr = [];\r\n  var fragmentSize = fragment.size;\r\n  var target = blockMap.get(targetKey);\r\n  var head = fragment.first();\r\n  var tail = fragment.last();\r\n  var finalOffset = tail.getLength();\r\n  var finalKey = tail.getKey();\r\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\r\n\r\n  blockMap.forEach(function (block, blockKey) {\r\n    if (blockKey !== targetKey) {\r\n      newBlockArr.push(block);\r\n      return;\r\n    }\r\n\r\n    if (shouldNotUpdateFromFragmentBlock) {\r\n      newBlockArr.push(block);\r\n    } else {\r\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\r\n    }\r\n\r\n    // Insert fragment blocks after the head and before the tail.\r\n    fragment\r\n    // when we are updating the target block with the head fragment block we skip the first fragment\r\n    // head since its contents have already been merged with the target block otherwise we include\r\n    // the whole fragment\r\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\r\n      return newBlockArr.push(fragmentBlock);\r\n    });\r\n\r\n    // update tail\r\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\r\n  });\r\n\r\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\r\n\r\n  if (isTreeBasedBlockMap) {\r\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\r\n  }\r\n\r\n  return contentState.merge({\r\n    blockMap: updatedBlockMap,\r\n    selectionBefore: selectionState,\r\n    selectionAfter: selectionState.merge({\r\n      anchorKey: finalKey,\r\n      anchorOffset: finalOffset,\r\n      focusKey: finalKey,\r\n      focusOffset: finalOffset,\r\n      isBackward: false\r\n    })\r\n  });\r\n};\r\n\r\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\r\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\r\n\r\n  var blockMap = contentState.getBlockMap();\r\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\r\n  var targetKey = selectionState.getStartKey();\r\n  var targetOffset = selectionState.getStartOffset();\r\n\r\n  var targetBlock = blockMap.get(targetKey);\r\n\r\n  if (targetBlock instanceof ContentBlockNode) {\r\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\r\n  }\r\n\r\n  // When we insert a fragment with a single block we simply update the target block\r\n  // with the contents of the inserted fragment block\r\n  if (fragment.size === 1) {\r\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\r\n  }\r\n\r\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\r\n};\r\n\r\nmodule.exports = insertFragmentIntoContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}