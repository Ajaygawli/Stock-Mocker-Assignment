{"ast":null,"code":"'use strict';\n\n/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule expandRangeToStartOfLine\r\n * @format\r\n * \r\n */\nvar UnicodeUtils = require('fbjs/lib/UnicodeUtils');\nvar getRangeClientRects = require('./getRangeClientRects');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\r\n * Return the computed line height, in pixels, for the provided element.\r\n */\nfunction getLineHeightPx(element) {\n  var computed = getComputedStyle(element);\n  var div = document.createElement('div');\n  div.style.fontFamily = computed.fontFamily;\n  div.style.fontSize = computed.fontSize;\n  div.style.fontStyle = computed.fontStyle;\n  div.style.fontWeight = computed.fontWeight;\n  div.style.lineHeight = computed.lineHeight;\n  div.style.position = 'absolute';\n  div.textContent = 'M';\n  var documentBody = document.body;\n  !documentBody ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing document.body') : invariant(false) : void 0;\n\n  // forced layout here\n  documentBody.appendChild(div);\n  var rect = div.getBoundingClientRect();\n  documentBody.removeChild(div);\n  return rect.height;\n}\n\n/**\r\n * Return whether every ClientRect in the provided list lies on the same line.\r\n *\r\n * We assume that the rects on the same line all contain the baseline, so the\r\n * lowest top line needs to be above the highest bottom line (i.e., if you were\r\n * to project the rects onto the y-axis, their intersection would be nonempty).\r\n *\r\n * In addition, we require that no two boxes are lineHeight (or more) apart at\r\n * either top or bottom, which helps protect against false positives for fonts\r\n * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino\r\n * produces rects of height 58px!).\r\n */\nfunction areRectsOnOneLine(rects, lineHeight) {\n  var minTop = Infinity;\n  var minBottom = Infinity;\n  var maxTop = -Infinity;\n  var maxBottom = -Infinity;\n  for (var ii = 0; ii < rects.length; ii++) {\n    var rect = rects[ii];\n    if (rect.width === 0 || rect.width === 1) {\n      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,\n      // Safari) include an empty rect on the previous or next line. When the\n      // text lies in a container whose position is not integral (e.g., from\n      // margin: auto), Safari makes these empty rects have width 1 (instead of\n      // 0). Having one-pixel-wide characters seems unlikely (and most browsers\n      // report widths in subpixel precision anyway) so it's relatively safe to\n      // skip over them.\n      continue;\n    }\n    minTop = Math.min(minTop, rect.top);\n    minBottom = Math.min(minBottom, rect.bottom);\n    maxTop = Math.max(maxTop, rect.top);\n    maxBottom = Math.max(maxBottom, rect.bottom);\n  }\n  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;\n}\n\n/**\r\n * Return the length of a node, as used by Range offsets.\r\n */\nfunction getNodeLength(node) {\n  // http://www.w3.org/TR/dom/#concept-node-length\n  switch (node.nodeType) {\n    case Node.DOCUMENT_TYPE_NODE:\n      return 0;\n    case Node.TEXT_NODE:\n    case Node.PROCESSING_INSTRUCTION_NODE:\n    case Node.COMMENT_NODE:\n      return node.length;\n    default:\n      return node.childNodes.length;\n  }\n}\n\n/**\r\n * Given a collapsed range, move the start position backwards as far as\r\n * possible while the range still spans only a single line.\r\n */\nfunction expandRangeToStartOfLine(range) {\n  !range.collapsed ? process.env.NODE_ENV !== 'production' ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;\n  range = range.cloneRange();\n  var containingElement = range.startContainer;\n  if (containingElement.nodeType !== 1) {\n    containingElement = containingElement.parentNode;\n  }\n  var lineHeight = getLineHeightPx(containingElement);\n\n  // Imagine our text looks like:\n  //   <div><span>once upon a time, there was a <em>boy\n  //   who lived</em> </span><q><strong>under^ the\n  //   stairs</strong> in a small closet.</q></div>\n  // where the caret represents the cursor. First, we crawl up the tree until\n  // the range spans multiple lines (setting the start point to before\n  // \"<strong>\", then before \"<div>\"), then at each level we do a search to\n  // find the latest point which is still on a previous line. We'll find that\n  // the break point is inside the span, then inside the <em>, then in its text\n  // node child, the actual break point before \"who\".\n\n  var bestContainer = range.endContainer;\n  var bestOffset = range.endOffset;\n  range.setStart(range.startContainer, 0);\n  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n    bestContainer = range.startContainer;\n    bestOffset = range.startOffset;\n    !bestContainer.parentNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;\n    range.setStartBefore(bestContainer);\n    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {\n      // The start of the line is never in a different block-level container.\n      break;\n    }\n  }\n\n  // In the above example, range now spans from \"<div>\" to \"under\",\n  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].\n  // Picking out which child to recurse into here is a special case since we\n  // don't want to check past <q> -- once we find that the final range starts\n  // in <span>, we can look at all of its children (and all of their children)\n  // to find the break point.\n\n  // At all times, (bestContainer, bestOffset) is the latest single-line start\n  // point that we know of.\n  var currentContainer = bestContainer;\n  var maxIndexToConsider = bestOffset - 1;\n  do {\n    var nodeValue = currentContainer.nodeValue;\n    for (var ii = maxIndexToConsider; ii >= 0; ii--) {\n      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {\n        // We're in the middle of a surrogate pair -- skip over so we never\n        // return a range with an endpoint in the middle of a code point.\n        continue;\n      }\n      range.setStart(currentContainer, ii);\n      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n        bestContainer = currentContainer;\n        bestOffset = ii;\n      } else {\n        break;\n      }\n    }\n    if (ii === -1 || currentContainer.childNodes.length === 0) {\n      // If ii === -1, then (bestContainer, bestOffset), which is equal to\n      // (currentContainer, 0), was a single-line start point but a start\n      // point before currentContainer wasn't, so the line break seems to\n      // have occurred immediately after currentContainer's start tag\n      //\n      // If currentContainer.childNodes.length === 0, we're already at a\n      // terminal node (e.g., text node) and should return our current best.\n      break;\n    }\n    currentContainer = currentContainer.childNodes[ii];\n    maxIndexToConsider = getNodeLength(currentContainer);\n  } while (true);\n  range.setStart(bestContainer, bestOffset);\n  return range;\n}\nmodule.exports = expandRangeToStartOfLine;","map":{"version":3,"names":["UnicodeUtils","require","getRangeClientRects","invariant","getLineHeightPx","element","computed","getComputedStyle","div","document","createElement","style","fontFamily","fontSize","fontStyle","fontWeight","lineHeight","position","textContent","documentBody","body","process","env","NODE_ENV","appendChild","rect","getBoundingClientRect","removeChild","height","areRectsOnOneLine","rects","minTop","Infinity","minBottom","maxTop","maxBottom","ii","length","width","Math","min","top","bottom","max","getNodeLength","node","nodeType","Node","DOCUMENT_TYPE_NODE","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","childNodes","expandRangeToStartOfLine","range","collapsed","cloneRange","containingElement","startContainer","parentNode","bestContainer","endContainer","bestOffset","endOffset","setStart","startOffset","setStartBefore","display","currentContainer","maxIndexToConsider","nodeValue","isSurrogatePair","module","exports"],"sources":["C:/Users/ajayg/Desktop/vssample/stock_mocker/client/node_modules/draft-js/lib/expandRangeToStartOfLine.js"],"sourcesContent":["'use strict';\r\n\r\n/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule expandRangeToStartOfLine\r\n * @format\r\n * \r\n */\r\n\r\nvar UnicodeUtils = require('fbjs/lib/UnicodeUtils');\r\n\r\nvar getRangeClientRects = require('./getRangeClientRects');\r\nvar invariant = require('fbjs/lib/invariant');\r\n\r\n/**\r\n * Return the computed line height, in pixels, for the provided element.\r\n */\r\nfunction getLineHeightPx(element) {\r\n  var computed = getComputedStyle(element);\r\n  var div = document.createElement('div');\r\n  div.style.fontFamily = computed.fontFamily;\r\n  div.style.fontSize = computed.fontSize;\r\n  div.style.fontStyle = computed.fontStyle;\r\n  div.style.fontWeight = computed.fontWeight;\r\n  div.style.lineHeight = computed.lineHeight;\r\n  div.style.position = 'absolute';\r\n  div.textContent = 'M';\r\n\r\n  var documentBody = document.body;\r\n  !documentBody ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing document.body') : invariant(false) : void 0;\r\n\r\n  // forced layout here\r\n  documentBody.appendChild(div);\r\n  var rect = div.getBoundingClientRect();\r\n  documentBody.removeChild(div);\r\n\r\n  return rect.height;\r\n}\r\n\r\n/**\r\n * Return whether every ClientRect in the provided list lies on the same line.\r\n *\r\n * We assume that the rects on the same line all contain the baseline, so the\r\n * lowest top line needs to be above the highest bottom line (i.e., if you were\r\n * to project the rects onto the y-axis, their intersection would be nonempty).\r\n *\r\n * In addition, we require that no two boxes are lineHeight (or more) apart at\r\n * either top or bottom, which helps protect against false positives for fonts\r\n * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino\r\n * produces rects of height 58px!).\r\n */\r\nfunction areRectsOnOneLine(rects, lineHeight) {\r\n  var minTop = Infinity;\r\n  var minBottom = Infinity;\r\n  var maxTop = -Infinity;\r\n  var maxBottom = -Infinity;\r\n\r\n  for (var ii = 0; ii < rects.length; ii++) {\r\n    var rect = rects[ii];\r\n    if (rect.width === 0 || rect.width === 1) {\r\n      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,\r\n      // Safari) include an empty rect on the previous or next line. When the\r\n      // text lies in a container whose position is not integral (e.g., from\r\n      // margin: auto), Safari makes these empty rects have width 1 (instead of\r\n      // 0). Having one-pixel-wide characters seems unlikely (and most browsers\r\n      // report widths in subpixel precision anyway) so it's relatively safe to\r\n      // skip over them.\r\n      continue;\r\n    }\r\n    minTop = Math.min(minTop, rect.top);\r\n    minBottom = Math.min(minBottom, rect.bottom);\r\n    maxTop = Math.max(maxTop, rect.top);\r\n    maxBottom = Math.max(maxBottom, rect.bottom);\r\n  }\r\n\r\n  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;\r\n}\r\n\r\n/**\r\n * Return the length of a node, as used by Range offsets.\r\n */\r\nfunction getNodeLength(node) {\r\n  // http://www.w3.org/TR/dom/#concept-node-length\r\n  switch (node.nodeType) {\r\n    case Node.DOCUMENT_TYPE_NODE:\r\n      return 0;\r\n    case Node.TEXT_NODE:\r\n    case Node.PROCESSING_INSTRUCTION_NODE:\r\n    case Node.COMMENT_NODE:\r\n      return node.length;\r\n    default:\r\n      return node.childNodes.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Given a collapsed range, move the start position backwards as far as\r\n * possible while the range still spans only a single line.\r\n */\r\nfunction expandRangeToStartOfLine(range) {\r\n  !range.collapsed ? process.env.NODE_ENV !== 'production' ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;\r\n  range = range.cloneRange();\r\n\r\n  var containingElement = range.startContainer;\r\n  if (containingElement.nodeType !== 1) {\r\n    containingElement = containingElement.parentNode;\r\n  }\r\n  var lineHeight = getLineHeightPx(containingElement);\r\n\r\n  // Imagine our text looks like:\r\n  //   <div><span>once upon a time, there was a <em>boy\r\n  //   who lived</em> </span><q><strong>under^ the\r\n  //   stairs</strong> in a small closet.</q></div>\r\n  // where the caret represents the cursor. First, we crawl up the tree until\r\n  // the range spans multiple lines (setting the start point to before\r\n  // \"<strong>\", then before \"<div>\"), then at each level we do a search to\r\n  // find the latest point which is still on a previous line. We'll find that\r\n  // the break point is inside the span, then inside the <em>, then in its text\r\n  // node child, the actual break point before \"who\".\r\n\r\n  var bestContainer = range.endContainer;\r\n  var bestOffset = range.endOffset;\r\n  range.setStart(range.startContainer, 0);\r\n\r\n  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\r\n    bestContainer = range.startContainer;\r\n    bestOffset = range.startOffset;\r\n    !bestContainer.parentNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;\r\n    range.setStartBefore(bestContainer);\r\n    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {\r\n      // The start of the line is never in a different block-level container.\r\n      break;\r\n    }\r\n  }\r\n\r\n  // In the above example, range now spans from \"<div>\" to \"under\",\r\n  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].\r\n  // Picking out which child to recurse into here is a special case since we\r\n  // don't want to check past <q> -- once we find that the final range starts\r\n  // in <span>, we can look at all of its children (and all of their children)\r\n  // to find the break point.\r\n\r\n  // At all times, (bestContainer, bestOffset) is the latest single-line start\r\n  // point that we know of.\r\n  var currentContainer = bestContainer;\r\n  var maxIndexToConsider = bestOffset - 1;\r\n\r\n  do {\r\n    var nodeValue = currentContainer.nodeValue;\r\n\r\n    for (var ii = maxIndexToConsider; ii >= 0; ii--) {\r\n      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {\r\n        // We're in the middle of a surrogate pair -- skip over so we never\r\n        // return a range with an endpoint in the middle of a code point.\r\n        continue;\r\n      }\r\n\r\n      range.setStart(currentContainer, ii);\r\n      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\r\n        bestContainer = currentContainer;\r\n        bestOffset = ii;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (ii === -1 || currentContainer.childNodes.length === 0) {\r\n      // If ii === -1, then (bestContainer, bestOffset), which is equal to\r\n      // (currentContainer, 0), was a single-line start point but a start\r\n      // point before currentContainer wasn't, so the line break seems to\r\n      // have occurred immediately after currentContainer's start tag\r\n      //\r\n      // If currentContainer.childNodes.length === 0, we're already at a\r\n      // terminal node (e.g., text node) and should return our current best.\r\n      break;\r\n    }\r\n\r\n    currentContainer = currentContainer.childNodes[ii];\r\n    maxIndexToConsider = getNodeLength(currentContainer);\r\n  } while (true);\r\n\r\n  range.setStart(bestContainer, bestOffset);\r\n  return range;\r\n}\r\n\r\nmodule.exports = expandRangeToStartOfLine;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}