{"ast":null,"code":"import utils from './utils';\nimport getOffsetParent from './getOffsetParent';\nimport isAncestorFixed from './isAncestorFixed';\n\n/**\n * 获得元素的显示部分的区域\n */\nfunction getVisibleRectForElement(element) {\n  var visibleRect = {\n    left: 0,\n    right: Infinity,\n    top: 0,\n    bottom: Infinity\n  };\n  var el = getOffsetParent(element);\n  var doc = utils.getDocument(element);\n  var win = doc.defaultView || doc.parentWindow;\n  var body = doc.body;\n  var documentElement = doc.documentElement;\n\n  // Determine the size of the visible rect by climbing the dom accounting for\n  // all scrollable containers.\n  while (el) {\n    // clientWidth is zero for inline block elements in ie.\n    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&\n    // body may have overflow set on it, yet we still get the entire\n    // viewport. In some browsers, el.offsetParent may be\n    // document.documentElement, so check for that too.\n    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {\n      var pos = utils.offset(el);\n      // add border\n      pos.left += el.clientLeft;\n      pos.top += el.clientTop;\n      visibleRect.top = Math.max(visibleRect.top, pos.top);\n      visibleRect.right = Math.min(visibleRect.right,\n      // consider area without scrollBar\n      pos.left + el.clientWidth);\n      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);\n      visibleRect.left = Math.max(visibleRect.left, pos.left);\n    } else if (el === body || el === documentElement) {\n      break;\n    }\n    el = getOffsetParent(el);\n  }\n\n  // Set element position to fixed\n  // make sure absolute element itself don't affect it's visible area\n  // https://github.com/ant-design/ant-design/issues/7601\n  var originalPosition = null;\n  if (!utils.isWindow(element) && element.nodeType !== 9) {\n    originalPosition = element.style.position;\n    var position = utils.css(element, 'position');\n    if (position === 'absolute') {\n      element.style.position = 'fixed';\n    }\n  }\n  var scrollX = utils.getWindowScrollLeft(win);\n  var scrollY = utils.getWindowScrollTop(win);\n  var viewportWidth = utils.viewportWidth(win);\n  var viewportHeight = utils.viewportHeight(win);\n  var documentWidth = documentElement.scrollWidth;\n  var documentHeight = documentElement.scrollHeight;\n\n  // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.\n  // We should cut this ourself.\n  var bodyStyle = window.getComputedStyle(body);\n  if (bodyStyle.overflowX === 'hidden') {\n    documentWidth = win.innerWidth;\n  }\n  if (bodyStyle.overflowY === 'hidden') {\n    documentHeight = win.innerHeight;\n  }\n\n  // Reset element position after calculate the visible area\n  if (element.style) {\n    element.style.position = originalPosition;\n  }\n  if (isAncestorFixed(element)) {\n    // Clip by viewport's size.\n    visibleRect.left = Math.max(visibleRect.left, scrollX);\n    visibleRect.top = Math.max(visibleRect.top, scrollY);\n    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);\n    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);\n  } else {\n    // Clip by document's size.\n    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);\n    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);\n    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);\n    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);\n  }\n  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;\n}\nexport default getVisibleRectForElement;","map":{"version":3,"names":["utils","getOffsetParent","isAncestorFixed","getVisibleRectForElement","element","visibleRect","left","right","Infinity","top","bottom","el","doc","getDocument","win","defaultView","parentWindow","body","documentElement","navigator","userAgent","indexOf","clientWidth","css","pos","offset","clientLeft","clientTop","Math","max","min","clientHeight","originalPosition","isWindow","nodeType","style","position","scrollX","getWindowScrollLeft","scrollY","getWindowScrollTop","viewportWidth","viewportHeight","documentWidth","scrollWidth","documentHeight","scrollHeight","bodyStyle","window","getComputedStyle","overflowX","innerWidth","overflowY","innerHeight","maxVisibleWidth","maxVisibleHeight"],"sources":["C:/Users/ajayg/Desktop/vssample/stock_mocker/client/node_modules/dom-align/es/getVisibleRectForElement.js"],"sourcesContent":["import utils from './utils';\nimport getOffsetParent from './getOffsetParent';\nimport isAncestorFixed from './isAncestorFixed';\n\n/**\n * 获得元素的显示部分的区域\n */\nfunction getVisibleRectForElement(element) {\n  var visibleRect = {\n    left: 0,\n    right: Infinity,\n    top: 0,\n    bottom: Infinity\n  };\n  var el = getOffsetParent(element);\n  var doc = utils.getDocument(element);\n  var win = doc.defaultView || doc.parentWindow;\n  var body = doc.body;\n  var documentElement = doc.documentElement;\n\n  // Determine the size of the visible rect by climbing the dom accounting for\n  // all scrollable containers.\n  while (el) {\n    // clientWidth is zero for inline block elements in ie.\n    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&\n    // body may have overflow set on it, yet we still get the entire\n    // viewport. In some browsers, el.offsetParent may be\n    // document.documentElement, so check for that too.\n    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {\n      var pos = utils.offset(el);\n      // add border\n      pos.left += el.clientLeft;\n      pos.top += el.clientTop;\n      visibleRect.top = Math.max(visibleRect.top, pos.top);\n      visibleRect.right = Math.min(visibleRect.right,\n      // consider area without scrollBar\n      pos.left + el.clientWidth);\n      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);\n      visibleRect.left = Math.max(visibleRect.left, pos.left);\n    } else if (el === body || el === documentElement) {\n      break;\n    }\n    el = getOffsetParent(el);\n  }\n\n  // Set element position to fixed\n  // make sure absolute element itself don't affect it's visible area\n  // https://github.com/ant-design/ant-design/issues/7601\n  var originalPosition = null;\n  if (!utils.isWindow(element) && element.nodeType !== 9) {\n    originalPosition = element.style.position;\n    var position = utils.css(element, 'position');\n    if (position === 'absolute') {\n      element.style.position = 'fixed';\n    }\n  }\n\n  var scrollX = utils.getWindowScrollLeft(win);\n  var scrollY = utils.getWindowScrollTop(win);\n  var viewportWidth = utils.viewportWidth(win);\n  var viewportHeight = utils.viewportHeight(win);\n  var documentWidth = documentElement.scrollWidth;\n  var documentHeight = documentElement.scrollHeight;\n\n  // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.\n  // We should cut this ourself.\n  var bodyStyle = window.getComputedStyle(body);\n  if (bodyStyle.overflowX === 'hidden') {\n    documentWidth = win.innerWidth;\n  }\n  if (bodyStyle.overflowY === 'hidden') {\n    documentHeight = win.innerHeight;\n  }\n\n  // Reset element position after calculate the visible area\n  if (element.style) {\n    element.style.position = originalPosition;\n  }\n\n  if (isAncestorFixed(element)) {\n    // Clip by viewport's size.\n    visibleRect.left = Math.max(visibleRect.left, scrollX);\n    visibleRect.top = Math.max(visibleRect.top, scrollY);\n    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);\n    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);\n  } else {\n    // Clip by document's size.\n    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);\n    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);\n\n    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);\n    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);\n  }\n\n  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;\n}\n\nexport default getVisibleRectForElement;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}